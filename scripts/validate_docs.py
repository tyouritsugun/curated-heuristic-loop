#!/usr/bin/env python
"""
Validate that documentation is accurate and up-to-date.

This script checks:
1. File paths referenced in docs actually exist
2. Script names in installation instructions are correct
3. Version numbers are consistent across docs
4. Environment variables are documented
5. Common documentation issues (broken internal links, outdated examples)

Usage:
    python scripts/validate_docs.py

Exit codes:
    0 - All checks passed (warnings are allowed)
    1 - Validation failures found
"""

from __future__ import annotations

import re
import sys
from pathlib import Path
from typing import List, Tuple


def check_file_references(doc_path: Path, project_root: Path) -> List[str]:
    """
    Check that all file/directory references in a markdown doc actually exist.

    Returns list of error messages (empty if all OK).
    """
    errors = []
    content = doc_path.read_text()

    # Files that are generated dynamically or are optional/TBD
    dynamic_files = {
        'data/support_prompt.txt',  # Generated by check_api_env.py
        'data/model_selection.json',  # Generated by check_api_env.py
    }

    # Pattern for markdown links: [text](path) or references to files
    # Also match code blocks with file paths like `src/api/server.py`
    patterns = [
        r'\[.*?\]\(((?!http)[^\)]+)\)',  # Markdown links (not URLs)
        r'`([a-zA-Z_][a-zA-Z0-9_/\.\-]*\.(?:py|txt|md|toml|yaml|json|sh))`',  # Inline code with file extensions
        r'see `([a-zA-Z_][a-zA-Z0-9_/\.\-]*/?)`',  # "see `path/to/dir/`" patterns
    ]

    for pattern in patterns:
        for match in re.finditer(pattern, content):
            file_ref = match.group(1)

            # Skip URLs, anchors, and special characters
            if any(skip in file_ref for skip in ['http://', 'https://', '#', '$', '*']):
                continue

            # Clean up the reference
            file_ref = file_ref.strip('/')

            # Skip dynamically generated files
            if file_ref in dynamic_files:
                continue

            # Try to resolve the path
            potential_paths = [
                project_root / file_ref,
                project_root / 'doc' / file_ref,
                project_root / 'scripts' / file_ref,
                project_root / 'src' / file_ref,
            ]

            if not any(p.exists() for p in potential_paths):
                errors.append(f"   Referenced file/dir not found: {file_ref}")

    return errors


def check_script_references(doc_path: Path, scripts_dir: Path) -> List[str]:
    """
    Check that script names mentioned in docs actually exist in scripts/.

    Returns list of error messages (empty if all OK).
    """
    errors = []
    content = doc_path.read_text()

    # Pattern for script references in command blocks
    # Example: python scripts/check_api_env.py
    script_pattern = r'python3?\s+scripts/([a-zA-Z0-9_\-]+\.py)'

    for match in re.finditer(script_pattern, content):
        script_name = match.group(1)
        script_path = scripts_dir / script_name

        if not script_path.exists():
            errors.append(f"   Referenced script not found: scripts/{script_name}")

    return errors


def check_version_consistency(project_root: Path) -> List[str]:
    """
    Check that version numbers are consistent across documentation files.

    Checks:
    - pyproject.toml version
    - API server version in server.py (if hardcoded)
    - README mentions of version (if any)

    Returns list of error messages (empty if all OK).
    """
    errors = []

    # Read version from pyproject.toml
    pyproject_path = project_root / "pyproject.toml"
    pyproject_content = pyproject_path.read_text()

    version_match = re.search(r'version\s*=\s*"([^"]+)"', pyproject_content)
    if not version_match:
        errors.append("   Could not find version in pyproject.toml")
        return errors

    pyproject_version = version_match.group(1)

    # Check src/api/server.py for hardcoded version
    server_path = project_root / "src" / "api" / "server.py"
    if server_path.exists():
        server_content = server_path.read_text()
        server_version_match = re.search(r'"version":\s*"([^"]+)"', server_content)

        if server_version_match:
            server_version = server_version_match.group(1)
            if server_version != pyproject_version:
                errors.append(
                    f"   Version mismatch: pyproject.toml={pyproject_version}, "
                    f"server.py={server_version}"
                )

    # If no errors, report the found version
    if not errors:
        # This is informational, not an error
        pass

    return errors


def check_requirements_references(doc_path: Path, project_root: Path) -> List[str]:
    """
    Check that requirements_*.txt files referenced in docs exist.

    Returns list of error messages (empty if all OK).
    """
    errors = []
    content = doc_path.read_text()

    # Requirements files that are planned but not yet implemented (TBD)
    tbd_requirements = {
        'requirements_rocm.txt',  # AMD ROCm support (TBD per README)
        'requirements_intel.txt',  # Intel GPU support (TBD per README)
    }

    # Pattern for requirements file references
    req_pattern = r'requirements_([a-z]+)\.txt'

    for match in re.finditer(req_pattern, content):
        req_file = f"requirements_{match.group(1)}.txt"

        # Skip TBD requirements files
        if req_file in tbd_requirements:
            continue

        req_path = project_root / req_file

        if not req_path.exists():
            errors.append(f"   Referenced requirements file not found: {req_file}")

    return errors


def check_env_var_documentation(doc_path: Path) -> Tuple[List[str], List[str]]:
    """
    Extract environment variables mentioned in documentation.

    Returns (errors, warnings) - both lists of strings.
    """
    errors = []
    warnings = []
    content = doc_path.read_text()

    # Common environment variables that should be documented
    expected_vars = {
        "CHL_SEARCH_MODE",
        "CHL_API_BASE_URL",
        "CHL_DATABASE_PATH",
        "CHL_EXPERIENCE_ROOT",
    }

    documented_vars = set(re.findall(r'`(CHL_[A-Z_]+)`', content))

    # Check if expected vars are documented
    missing = expected_vars - documented_vars

    if missing and doc_path.name in ["README.md", "manual.md"]:
        warnings.append(f"   Some env vars may not be documented: {', '.join(sorted(missing))}")

    return errors, warnings


def validate_readme(project_root: Path) -> bool:
    """
    Validate README.md for common issues.

    Returns True if valid, False otherwise.
    """
    print("üìÑ Validating README.md...")

    readme_path = project_root / "README.md"
    if not readme_path.exists():
        print("‚ùå README.md not found")
        return False

    scripts_dir = project_root / "scripts"
    all_errors = []

    # Check file references
    errors = check_file_references(readme_path, project_root)
    all_errors.extend(errors)

    # Check script references
    errors = check_script_references(readme_path, scripts_dir)
    all_errors.extend(errors)

    # Check requirements file references
    errors = check_requirements_references(readme_path, project_root)
    all_errors.extend(errors)

    # Check environment variable documentation
    errors, warnings = check_env_var_documentation(readme_path)
    all_errors.extend(errors)

    if warnings:
        for warning in warnings:
            print(f"‚ö†Ô∏è  {warning}")

    if all_errors:
        print("‚ùå README.md validation failed:")
        for error in all_errors:
            print(error)
        return False

    print("‚úÖ README.md validation passed")
    return True


def validate_architecture_doc(project_root: Path) -> bool:
    """
    Validate doc/architecture.md for common issues.

    Returns True if valid, False otherwise.
    """
    print("\nüìÑ Validating doc/architecture.md...")

    arch_path = project_root / "doc" / "architecture.md"
    if not arch_path.exists():
        print("‚ö†Ô∏è  doc/architecture.md not found (optional)")
        return True

    all_errors = []

    # Check file references
    errors = check_file_references(arch_path, project_root)
    all_errors.extend(errors)

    if all_errors:
        print("‚ùå doc/architecture.md validation failed:")
        for error in all_errors:
            print(error)
        return False

    print("‚úÖ doc/architecture.md validation passed")
    return True


def validate_manual_doc(project_root: Path) -> bool:
    """
    Validate doc/manual.md for common issues.

    Returns True if valid, False otherwise.
    """
    print("\nüìÑ Validating doc/manual.md...")

    manual_path = project_root / "doc" / "manual.md"
    if not manual_path.exists():
        print("‚ö†Ô∏è  doc/manual.md not found (optional)")
        return True

    scripts_dir = project_root / "scripts"
    all_errors = []

    # Check file references
    errors = check_file_references(manual_path, project_root)
    all_errors.extend(errors)

    # Check script references
    errors = check_script_references(manual_path, scripts_dir)
    all_errors.extend(errors)

    if all_errors:
        print("‚ùå doc/manual.md validation failed:")
        for error in all_errors:
            print(error)
        return False

    print("‚úÖ doc/manual.md validation passed")
    return True


def main() -> int:
    """Run all documentation validation checks."""
    print("=" * 60)
    print("CHL Documentation Validation")
    print("=" * 60)
    print()

    project_root = Path(__file__).parent.parent

    # Check version consistency first
    print("üîç Checking version consistency...")
    version_errors = check_version_consistency(project_root)
    if version_errors:
        print("‚ùå Version consistency check failed:")
        for error in version_errors:
            print(error)
        version_valid = False
    else:
        print("‚úÖ Version numbers are consistent")
        version_valid = True

    print()

    # Validate individual docs
    results = [
        version_valid,
        validate_readme(project_root),
        validate_architecture_doc(project_root),
        validate_manual_doc(project_root),
    ]

    # Final summary
    print("\n" + "=" * 60)
    if all(results):
        print("‚úÖ All documentation validation checks passed!")
        print("=" * 60)
        print("\nDocumentation is accurate and up-to-date:")
        print("  ‚úÖ File references are valid")
        print("  ‚úÖ Script names are correct")
        print("  ‚úÖ Version numbers are consistent")
        print("  ‚úÖ No broken internal links found")
        return 0
    else:
        print("‚ùå Documentation validation FAILED")
        print("=" * 60)
        print("\nPlease fix the issues above and re-run this script.")
        print("\nTips:")
        print("  - Update file paths that have been moved or renamed")
        print("  - Check that script names in installation commands are correct")
        print("  - Ensure version numbers match across pyproject.toml and server.py")
        return 1


if __name__ == "__main__":
    sys.exit(main())
